#!/usr/bin/env python3

import datetime
import os
import requests
import subprocess

# work around ipv6 bug on Ubuntu 22.04
requests.packages.urllib3.util.connection.HAS_IPV6 = False

IMAGES_PATH = "/tmp/apodesktop"


def getNumberOfMonitors():
    # If using GNOME, we might be on Wayland where xrandr doesn't work well
    # but for now we'll check if DISPLAY is present as a fallback
    xrandrOutput = subprocess.check_output(["xrandr"], text=True)
    number_of_monitors = xrandrOutput.count(" connected")
    return number_of_monitors


def getAPODImageURLs(date, number_of_days_to_look_back):
    assert isinstance(date, datetime.datetime), "Date is not a datetime object"
    assert (
        number_of_days_to_look_back > 0
    ), "Number of days to look back is not positive"

    dateToCheck = date - datetime.timedelta(days=number_of_days_to_look_back)
    formattedDate = dateToCheck.strftime("%Y-%m-%d")
    # MUST FIX: Remove the API key from the code before sharing
    apodURL = f"https://api.nasa.gov/planetary/apod?api_key=JvhDwQU1Uhv7yfaQTSqcsncZjwF5ZJR6McrzVE4f&start_date={formattedDate}"
    response = requests.get(apodURL)
    assert (
        response.status_code == 200
    ), f"Failed to get APOD. Status code: {response.status_code}"

    responseJSON = response.json()
    assert isinstance(responseJSON, list), "APOD response is not a list"

    apodImageURLs = [
        entry["hdurl"] or entry["url"]
        for entry in responseJSON
        if entry["media_type"] == "image"
    ]
    assert len(apodImageURLs) > 0, "No APOD images found"

    # reverse the list so that the most recent image is first
    return list(reversed(apodImageURLs))


def downloadImages(apodImageURLs):
    assert len(apodImageURLs) > 0, "No APOD images to download"

    def downloadImage(apodImageURL, tempDir):
        imageName = apodImageURL.split("/")[-1]
        if os.path.exists(tempDir + "/" + imageName):
            return tempDir + "/" + imageName
        response = requests.get(apodImageURL)
        if response.status_code != 200:
            print(f"Failed to download from {apodImageURL}: {response.status_code}")
            return None
        if not response.headers.get("Content-Type", "").startswith("image"):
            print(
                f"Downloaded file from {apodImageURL} is not an image (MIME type: {response.headers.get('Content-Type', 'unknown')})"
            )
            return None
        assert (
            response.status_code == 200
        ), f"Failed to download image. Status code: {response.status_code}"
        assert (
            "image" in response.headers["Content-Type"]
        ), "Downloaded file is not an image"

        with open(tempDir + "/" + imageName, "wb") as imageFile:
            imageFile.write(response.content)
        return tempDir + "/" + imageName

    tempDir = IMAGES_PATH
    os.makedirs(tempDir, exist_ok=True)
    pathsToImages = [
        downloadImage(apodImageURL, tempDir) for apodImageURL in apodImageURLs
    ]
    # Filter out None values (failed downloads)
    pathsToImages = [path for path in pathsToImages if path is not None]
    return pathsToImages


def createCombinedWallpaper(pathsToImages, monitors):
    from PIL import Image

    # Calculate total canvas size
    max_x = max(m["x"] + m["w"] for m in monitors)
    max_y = max(m["y"] + m["h"] for m in monitors)
    canvas = Image.new("RGB", (max_x, max_y))

    for i, m in enumerate(monitors):
        img_path = pathsToImages[i % len(pathsToImages)]
        img = Image.open(img_path)
        # Simple zoom/fill logic for each monitor
        img_ratio = img.width / img.height
        mon_ratio = m["w"] / m["h"]
        if img_ratio > mon_ratio:
            new_h = m["h"]
            new_w = int(new_h * img_ratio)
        else:
            new_w = m["w"]
            new_h = int(new_w / img_ratio)

        img = img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        # Crop to monitor size
        left = (new_w - m["w"]) / 2
        top = (new_h - m["h"]) / 2
        img = img.crop((left, top, left + m["w"], top + m["h"]))
        canvas.paste(img, (m["x"], m["y"]))

    combined_path = os.path.join(IMAGES_PATH, "combined_wallpaper.jpg")
    canvas.save(combined_path, quality=95)
    return combined_path


def setWallpaperGnome(pathsToImages):
    import re

    # Get monitor geometry from xrandr
    monitors = []
    xrandrOutput = subprocess.check_output(["xrandr", "--query"], text=True)
    # Regex to find: DP-1 connected 5120x2880+6144+0 (normal) or 5120x2880+6144+0 (primary)
    pattern = re.compile(r"(\d+)x(\d+)\+(\d+)\+(\d+)")
    for line in xrandrOutput.splitlines():
        if " connected" in line:
            match = pattern.search(line)
            if match:
                w, h, x, y = map(int, match.groups())
                monitors.append({"w": w, "h": h, "x": x, "y": y})

    assert len(monitors) > 0, "No monitors detected from xrandr output"
    print(f"Detected {len(monitors)} monitors")

    combined_path = createCombinedWallpaper(pathsToImages, monitors)

    uri = f"file://{os.path.abspath(combined_path)}"
    subprocess.run(
        [
            "gsettings",
            "set",
            "org.gnome.desktop.background",
            "picture-options",
            "spanned",
        ]
    )
    subprocess.run(
        ["gsettings", "set", "org.gnome.desktop.background", "picture-uri", uri]
    )
    subprocess.run(
        ["gsettings", "set", "org.gnome.desktop.background", "picture-uri-dark", uri]
    )


def setWallpaper(pathsToImages):
    assert len(pathsToImages) > 0, "No images to set as wallpaper"

    desktop_session = os.environ.get("XDG_CURRENT_DESKTOP", "").lower()
    gdm_session = os.environ.get("GDMSESSION", "").lower()
    is_gnome = "gnome" in desktop_session and "i3" not in gdm_session

    if is_gnome:
        print("Using GNOME-specific wallpaper setting")
        setWallpaperGnome(pathsToImages)
    else:
        print("Using feh to set wallpaper")
        assert "DISPLAY" in os.environ, "Not using X11"
        command = ["feh", "--bg-fill"] + pathsToImages
        subprocess.run(command)


def main():
    number_of_monitors = getNumberOfMonitors()
    assert number_of_monitors > 0, "No monitors detected"
    print(f"Detected {number_of_monitors} monitors from xrandr")

    # look back two extra days in case the APOD is a video
    number_of_days_to_look_back = number_of_monitors + 2
    date_n_days_ago = datetime.datetime.now() - datetime.timedelta(
        days=number_of_days_to_look_back
    )
    print(f"Looking back {number_of_days_to_look_back} days from {date_n_days_ago}")

    apodImageURLs = getAPODImageURLs(
        datetime.datetime.now(), number_of_days_to_look_back
    )
    print(f"Found {len(apodImageURLs)} images to download")
    assert len(apodImageURLs) > 0, "No APOD images found"

    pathsToImages = downloadImages(apodImageURLs)
    print(f"Downloaded {len(pathsToImages)} images")
    assert len(pathsToImages) > 0, "No images downloaded"

    setWallpaper(pathsToImages)
    print(f"Set {number_of_monitors} desktop images")

    return 0


if __name__ == "__main__":
    main()
