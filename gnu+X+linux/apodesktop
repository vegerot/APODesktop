#!/usr/bin/env python3

import datetime
import os
import subprocess
import urllib.request
import json
import re

# work around ipv6 bug on Ubuntu 22.04
# Note: urllib.request doesn't have a direct equivalent to requests' HAS_IPV6 toggle 
# but it generally handles it gracefully or follows system preferences.

IMAGES_PATH = "/tmp/apodesktop"

def http_get_json(url):
    with urllib.request.urlopen(url) as response:
        assert response.status == 200, f"Failed to get JSON. Status code: {response.status}"
        return json.loads(response.read().decode())

def http_download(url, dest_path):
    # Some URLs might need a user-agent if they block default python-urllib
    req = urllib.request.Request(url)
    with urllib.request.urlopen(req) as response:
        assert response.status == 200, f"Failed to download image. Status code: {response.status}"
        content_type = response.info().get('Content-Type', '')
        assert "image" in content_type, f"Downloaded file is not an image ({content_type})"
        with open(dest_path, 'wb') as f:
            f.write(response.read())
        return content_type

def getNumberOfMonitors():
    desktop_session = os.environ.get("XDG_CURRENT_DESKTOP", "").lower()
    
    if "hyprland" in desktop_session:
        output = subprocess.check_output(["hyprctl", "monitors", "-j"], text=True)
        monitors_data = json.loads(output)
        # Filter only active monitors
        return [{"w": m["width"], "h": m["height"], "x": m["x"], "y": m["y"], "name": m["name"]} for m in monitors_data if not m.get("disabled", False)]
    else:
        monitors = []
        xrandrOutput = subprocess.check_output(["xrandr", "--query"], text=True)
        pattern = re.compile(r"(\d+)x(\d+)\+(\d+)\+(\d+)")
        for line in xrandrOutput.splitlines():
            if " connected" in line:
                match = pattern.search(line)
                if match:
                    w, h, x, y = map(int, match.groups())
                    monitors.append({"w": w, "h": h, "x": x, "y": y, "name": None})
        return monitors

def getAPODImageURLs(date, number_of_days_to_look_back):
    assert isinstance(date, datetime.datetime), "Date is not a datetime object"
    assert number_of_days_to_look_back > 0, "Number of days to look back is not positive"

    dateToCheck = date - datetime.timedelta(days=number_of_days_to_look_back)
    formattedDate = dateToCheck.strftime("%Y-%m-%d")
    
    # MUST FIX: Remove the API key from the code before sharing
    apodURL = f"https://api.nasa.gov/planetary/apod?api_key=JvhDwQU1Uhv7yfaQTSqcsncZjwF5ZJR6McrzVE4f&start_date={formattedDate}"
    
    responseJSON = http_get_json(apodURL)
    assert isinstance(responseJSON, list), "APOD response is not a list"
    
    apodImageURLs = [
        entry.get("hdurl") or entry.get("url")
        for entry in responseJSON
        if entry.get("media_type") == "image"
    ]
    assert len(apodImageURLs) > 0, "No APOD images found"
    
    # reverse the list so that the most recent image is first
    return list(reversed(apodImageURLs))

def downloadImages(apodImageURLs):
    assert len(apodImageURLs) > 0, "No APOD images to download"
    
    def downloadImage(apodImageURL, tempDir):
        imageName = apodImageURL.split("/")[-1]
        dest = os.path.join(tempDir, imageName)
        if os.path.exists(dest):
            return dest
        try:
            print(f"Downloading {apodImageURL}...")
            http_download(apodImageURL, dest)
            return dest
        except Exception as e:
            print(f"Failed to download {apodImageURL}: {e}")
            return None

    tempDir = IMAGES_PATH
    os.makedirs(tempDir, exist_ok=True)
    pathsToImages = [
        downloadImage(apodImageURL, tempDir) for apodImageURL in apodImageURLs
    ]
    # Filter out None values (failed downloads)
    pathsToImages = [path for path in pathsToImages if path is not None]
    
    assert len(pathsToImages) > 0, "No images downloaded"
    return pathsToImages

def createCombinedWallpaper(pathsToImages, monitors):
    from PIL import Image
    
    # Calculate total canvas size
    max_x = max(m["x"] + m["w"] for m in monitors)
    max_y = max(m["y"] + m["h"] for m in monitors)
    canvas = Image.new("RGB", (max_x, max_y))

    for i, m in enumerate(monitors):
        img_path = pathsToImages[i % len(pathsToImages)]
        img = Image.open(img_path)
        
        # Simple zoom/fill logic for each monitor
        img_ratio = img.width / img.height
        mon_ratio = m["w"] / m["h"]
        if img_ratio > mon_ratio:
            new_h = m["h"]
            new_w = int(new_h * img_ratio)
        else:
            new_w = m["w"]
            new_h = int(new_w / img_ratio)

        img = img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        # Crop to monitor size
        left = (new_w - m["w"]) / 2
        top = (new_h - m["h"]) / 2
        img = img.crop((left, top, left + m["w"], top + m["h"]))
        canvas.paste(img, (m["x"], m["y"]))

    combined_path = os.path.join(IMAGES_PATH, "combined_wallpaper.jpg")
    canvas.save(combined_path, quality=95)
    return combined_path

def setWallpaper(pathsToImages, monitors):
    assert len(pathsToImages) > 0, "No images to set as wallpaper"
    
    def setWallpaperHyprland(pathsToImages, monitors):
        # Kill existing swaybg
        subprocess.run(["pkill", "swaybg"])
        
        for i, m in enumerate(monitors):
            img = pathsToImages[i % len(pathsToImages)]
            print(f"Setting wallpaper for {m.get('name', 'monitor '+str(i))} to {img}")
            # Running swaybg per monitor
            if m.get("name"):
                subprocess.Popen(["swaybg", "-o", m["name"], "-i", img, "-m", "fill"])
            else:
                subprocess.Popen(["swaybg", "-i", img, "-m", "fill"])

    def setWallpaperGnome(pathsToImages, monitors):
        print("Using GNOME-specific wallpaper setting")
        # For GNOME, we try to use PIL if available to create a spanned wallpaper
        try:
            combined_path = createCombinedWallpaper(pathsToImages, monitors)
            uri = f"file://{os.path.abspath(combined_path)}"
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-options", "spanned"])
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-uri", uri])
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-uri-dark", uri])
        except ImportError:
            print("PIL not found, setting first image as wallpaper")
            uri = f"file://{os.path.abspath(pathsToImages[0])}"
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-options", "zoom"])
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-uri", uri])
            subprocess.run(["gsettings", "set", "org.gnome.desktop.background", "picture-uri-dark", uri])

    desktop_session = os.environ.get("XDG_CURRENT_DESKTOP", "").lower()
    gdm_session = os.environ.get("GDMSESSION", "").lower()
    is_gnome = "gnome" in desktop_session and "i3" not in gdm_session

    if "hyprland" in desktop_session:
        setWallpaperHyprland(pathsToImages, monitors)
    elif is_gnome:
        setWallpaperGnome(pathsToImages, monitors)
    else:
        print("Using feh to set wallpaper")
        assert "DISPLAY" in os.environ or "WAYLAND_DISPLAY" in os.environ, "No display found"
        subprocess.run(["feh", "--bg-fill"] + pathsToImages)

def main():
    monitors = getNumberOfMonitors()
    assert len(monitors) > 0, "No monitors detected"
    print(f"Detected {len(monitors)} monitors")

    # look back a few extra days in case the APOD is a video
    number_of_days_to_look_back = len(monitors) + 2
    
    apodImageURLs = getAPODImageURLs(datetime.datetime.now(), number_of_days_to_look_back)
    print(f"Found {len(apodImageURLs)} images to download")

    pathsToImages = downloadImages(apodImageURLs)
    print(f"Downloaded {len(pathsToImages)} images")

    setWallpaper(pathsToImages, monitors)
    print(f"Set wallpaper for {len(monitors)} monitors")
    return 0

if __name__ == "__main__":
    main()
